```
12.1 이진 검색 트리의 개념

이진 검색 트리는 이름에서 알 수 있듯이, 그리고 그림 12.1와 같이 이진 트리 형태다. 각 노드를 객체로 하는 연결 자료구조로 이런 트리를 표현할 수 있다. 또한 key, 부속 데이터(satellite data)와 함께 left, right, p 필드를 가지는데, 이들은 각각 왼쪽 자식, 오른쪽 자식, 부모에 해당하는 노드를 가리킨다. 

자식이나 부모가 없으면 해당 필드는 NIL값을 가진다.
그리고 루트 노드는 부모가 NIL인 유일한 노드다.

이진 검색 트리에서 키들은 항상 다음의 이진 검색 트리 특성(binary-search-tree-property)을 만족하도록 저장된다. 

x를 이진 검색 트리의 한 노드라고 하자. y가 x의 왼쪽 서브 트리의 한 노드면 y.key<=x.key를 만족한다. 그리고 y가 x의 오른쪽 서브 트리의 한 노드면 y.key>=x.key를 만족한다.

따라서 그림 12.1(a)에서 루트의 키는 6이고 왼쪽 서브 트리의 키 2, 5, 5는 6보다 크지 않고, 오른쪽 서브 트리의 키 7과 8은 6보다 작지 않다.

이와 같은 특성은 트리의 모든 노드에 대해 만족한다.
예를 들어, 루트의 왼쪽 자식의 키 5는 그것의 왼쪽 서브 트리에 있는 키 2보다 작지 않고, 그것의 오른쪽 서브 트리의 키 5보다 크지 않다.

이진 검색 트리 특성에 의해 중위 트리 순회(inorder tree walk)라고 하는 간단한 재귀 알고리즘을 통해서
이진 검색 트리의 모든 키를 정렬된 순서대로 출력할 수 있다.
이 알고리즘 이름은 루트의 키를 왼쪽 서브 트리의 키와 오른쪽 서브 트리의 키 사이에 출력한다는 사실에서 유래한다.
(이와 유사하게, 전위 트리 순회(preorder tree walk)는 루트를 양쪽 서브 트리의 키보다 먼저 출력하고,
 후위 트리 순회(postorder tree walk)는 루트를 양쪽 서브 트리의 키보다 나중에 출력한다.)

이진 검색 트리 T의 모든 원소를 출력하려면 다음 프로시저 INORDER-TREE-WALK의 (T.root)를 호출하면 된다.

INORDER-TREE-WALK(x)
if x != NIL
  INORDER-TREE-WALK(x.left)
  print x.key
  INORDER-TREE-WALK(x.right)

예를 들어, 중위 트리 순회는 그림 12.1의 두 가지 이진 검색 트리의 키를 모두 2, 5, 5, 6, 7, 8의 순서로 출력한다.
이 알고리즘의 정확성은 수학적 귀납법을 이용해 이진 검색 트리 특성으로부터 바로 이끌어낼 수 있다.

초기의 호출 이후 이 프로시저는 트리의 각 노드에 대해 재귀적으로 정확히 두 번(왼쪽 자식에 대해 한 번, 오른쪽 자식에 대해 한 번)씩
자기 호출을 호출하므로 n개의 노드로 이루어진 이진 검색 트리를 순회하는데 O(n) 시간이 걸린다.
다음 정리를 통해 중위 트리 순회를 수행하는데 선형적인 시간이 걸림을 증명할 수 있다.

정리 12.1
x가 n개의 노드로 이루어진 서브 트리의 루트면 INORDER-TREE-WALK(x)는 O(n) 시간이 걸린다.

증명
- INORDER-TREE-WALK를 n개의 노드로 이루어진 서브 트리의 루트에 대해서 호출했을 때,
  걸리는 시간을 T(n)이라고 하자. INORDER-TREE-WALK는 n개의 노드를 모두 방문하기 때문에, T(n) = 오메가(n)이다.
  T(n) = O(n) 임을 보이는 것만 남았다.

- 빈 트리(x != NIL인 경우)에 대해 INORDER-TREE-WALK는 경미한 상수 시간이 걸리므로,
  어떤 상수 c > 0에 대해 T(0) = C다.

- n > 0인 경우 INORDER-TREE-WALK가 왼쪽 서브 트리는 k개의 노드를 가지고, 오른쪽 서브 트리는 n-k-1개의 노드를 가지는
  노드 x에 대해 호출되었다고 가정하자.
  INORDER-TREE-WALK(x)를 수행하는데 필요한 시간은 T(n) <= T(k)+T(n-k-1)+d인데,
  상수 d > 0은 INORDER-TREE-WALK(x)를 수행하는데 재귀 호출에 걸리는 시간 외의 상한을 반영한다.

- T(n) = O(n)임을 보이기 위해 치환법을 사용하는데, T(n) <= (c+d)n + c임을 보이면 된다.
  n = 0일 때, (c+d)*0 + c = c = T(0)이므로 만족한다.
  n > 0 일 때 다음이 되므로 증명되었다.

T(n) <= T(K) + T(n-k-1) + d
     <= ((c+d)k + c) + ((c + d)(n-k-1)+c) + d
     = (c+d)n + c - (c + d) + c + d
     = (c+d)n
```



```
