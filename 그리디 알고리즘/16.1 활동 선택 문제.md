
```
그리디 알고리즘의 첫 번째 예는 공유 자원 하나를 서로 배타적으로 사용해야 하는 여러 개의 경쟁하는 활동이 주어졌을 때,
서로 양립할 수 있는 활동의 집합 중에서 크기가 가장 큰 것을 뽑아내는 스케줄을 짜는 문제다.

예를 들어, 한 번에 활동을 단 한 개만 처리할 수 있는 강의실과 같은 자원을 요구하는 n개의 제안된 활동의 집합
S = {a1, a2, ... an}이 있다고 가정하자.
각 활동 ai는 시작 시간(start time) si와 종료 시간(finish time) fi가 있는데,
이들은 0<=si < fi < 무한대 라는 조건을 만족한다.

활동 ai가 선택되었다면 이 활동은 반쪽만 열린 시간 구간 [si, fi) 동안 일어난다.
활동 ai와 aj는 [si, fi)와 [sj, fj)가 서로 겹치지 않으면 함께 양립할 수 있다.
즉, ai와 aj는 si>=fj 또는 sj >= fi이면 양립 가능하다.

활동 선택 문제(activity-selection problem)에서 서로 양립할 수 있는 활동들로 이루어진 최대 크기의 부분 집합을 찾고자 한다.
다음과 같이 종료 시간이 단조증가하는 순서로 활동이 정렬되어 있다고 가정한다.
(이런 가정이 제공하는 장점을 나중에 보게 될 것이다)

f1<=f2<=f3 <= ... <= fn-1 <= fn

예를 들면, 다음의 활동 집합 S를 고려해보자.

이 예를 보면 부분 집합 {a3, a9, a11}은 상호 양립 가능한 활동들로 이루어져 있다.
하지만 부분 집합 {a1, a4, a8, a11}이 더 크므로 이것은 최대 크기의 부분 집합이 아니다.
사실 {a1, a4, a8, a11}이 상호 양립 가능한 활동 중에서 가장 큰 부분 집합이며,
또 다른 최대 크기의 부분 집합은 {a2, a4, a9, a11}이다.

이 문제를 몇 단계로 나누어서 해결할 것이다. 어떤 부분 문제를 최적해에서 사용할지를 결정할 때,
여러 가지 선택을 고려하는 동적 프로그래밍의 해에 대해서 생각해 보는 것으로 시작한다.
한 가지 선택(그리디 선택)만을 고려하면 되고, 그리디 선택을 할 때는 단 한 개의 부분 문제만 남는다는 사실을 관찰하게 될 것이다.
이런 관찰에 근거하여 활동 선택 문제를 풀기 위해 재귀 그리디 알고리즘을 개발할 것이다.

그리고 재귀 알고리즘을 반복적 순환 형태로 변환하여 그리디 해법을 개발하는 과정을 마칠 예정이다.
이 절에서 살펴볼 단계들은 그리디 알고리즘을 일반적으로 개발할때보다 복잡한 단계를 거치는데,
이는 그리디 알고리즘과 동적 프로그래밍의 관계를 잘 묘사해주기 위함이다. 


## 활동 선택 문제의 최적 부분 구조
- 활동 선택 문제가 최적 부분 구조를 갖는 것은 쉽게 증명된다.
  

```
